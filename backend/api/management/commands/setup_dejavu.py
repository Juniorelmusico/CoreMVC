"""
Comando de Django para configurar el sistema de reconocimiento de audio personalizado
"""
from django.core.management.base import BaseCommand
from django.conf import settings
from django.db import models
from api.models import Track, Artist, Genre, Mood
from api.dejavu_service import audio_recognition_service
from api.tasks import fingerprint_track, predict_genre_from_filename, predict_mood_from_filename
import os


class Command(BaseCommand):
    help = 'Configura el sistema de reconocimiento de audio y migra datos existentes'

    def add_arguments(self, parser):
        parser.add_argument(
            '--fingerprint-existing',
            action='store_true',
            help='Generar fingerprints para tracks existentes',
        )
        parser.add_argument(
            '--create-sample-data',
            action='store_true',
            help='Crear datos de ejemplo',
        )
        parser.add_argument(
            '--test-service',
            action='store_true',
            help='Probar el servicio de reconocimiento',
        )
        parser.add_argument(
            '--show-stats',
            action='store_true',
            help='Mostrar estad√≠sticas del sistema',
        )

    def handle(self, *args, **options):
        self.stdout.write(
            self.style.SUCCESS('üéµ Configurando sistema de reconocimiento de audio para Melocuore...')
        )

        # Probar servicio de reconocimiento
        if options['test_service']:
            self.test_recognition_service()

        # Crear datos de ejemplo
        if options['create_sample_data']:
            self.create_sample_data()

        # Generar fingerprints para tracks existentes
        if options['fingerprint_existing']:
            self.fingerprint_existing_tracks()
            
        # Mostrar estad√≠sticas
        if options['show_stats']:
            self.show_statistics()

        self.stdout.write(
            self.style.SUCCESS('‚úÖ Configuraci√≥n completada!')
        )

    def test_recognition_service(self):
        """Probar el servicio de reconocimiento"""
        self.stdout.write('üîç Probando servicio de reconocimiento...')
        
        try:
            # Probar creaci√≥n de servicio
            service = audio_recognition_service
            
            self.stdout.write(
                self.style.SUCCESS('‚úÖ Servicio de reconocimiento inicializado correctamente')
            )
            
            # Mostrar configuraci√≥n
            self.stdout.write('üìã Configuraci√≥n del servicio:')
            self.stdout.write(f'  - Sample rate: {service.fingerprint.sample_rate} Hz')
            self.stdout.write(f'  - FFT size: {service.fingerprint.n_fft}')
            self.stdout.write(f'  - Hop length: {service.fingerprint.hop_length}')
            self.stdout.write(f'  - MEL bands: {service.fingerprint.n_mels}')
            self.stdout.write(f'  - Cache timeout: {service.cache_timeout} segundos')
                    
        except Exception as e:
            self.stdout.write(
                self.style.ERROR(f'‚ùå Error probando servicio: {str(e)}')
            )

    def create_sample_data(self):
        """Crear datos de ejemplo"""
        self.stdout.write('üìù Creando datos de ejemplo...')
        
        # Crear g√©neros de ejemplo
        genres_data = [
            {'name': 'Electronic', 'description': 'M√∫sica electr√≥nica', 'color_code': '#00ff00'},
            {'name': 'Rock', 'description': 'M√∫sica rock', 'color_code': '#ff0000'},
            {'name': 'Pop', 'description': 'M√∫sica pop', 'color_code': '#ff69b4'},
            {'name': 'Jazz', 'description': 'M√∫sica jazz', 'color_code': '#4169e1'},
            {'name': 'Classical', 'description': 'M√∫sica cl√°sica', 'color_code': '#8b4513'},
            {'name': 'Hip Hop', 'description': 'M√∫sica hip hop', 'color_code': '#ffa500'},
            {'name': 'Reggae', 'description': 'M√∫sica reggae', 'color_code': '#32cd32'},
            {'name': 'Country', 'description': 'M√∫sica country', 'color_code': '#daa520'},
            {'name': 'Blues', 'description': 'M√∫sica blues', 'color_code': '#4682b4'},
            {'name': 'Alternative', 'description': 'M√∫sica alternativa', 'color_code': '#9932cc'},
        ]
        
        for genre_data in genres_data:
            genre, created = Genre.objects.get_or_create(
                name=genre_data['name'],
                defaults=genre_data
            )
            if created:
                self.stdout.write(f'  ‚úÖ G√©nero creado: {genre.name}')

        # Crear moods de ejemplo
        moods_data = [
            {'name': 'Happy', 'description': 'Alegre y positivo', 'valence_score': 0.8},
            {'name': 'Sad', 'description': 'Triste y melanc√≥lico', 'valence_score': -0.6},
            {'name': 'Energetic', 'description': 'Energ√©tico y motivador', 'valence_score': 0.9},
            {'name': 'Calm', 'description': 'Calmado y relajante', 'valence_score': 0.2},
            {'name': 'Aggressive', 'description': 'Agresivo e intenso', 'valence_score': -0.2},
            {'name': 'Romantic', 'description': 'Rom√°ntico y emotivo', 'valence_score': 0.5},
            {'name': 'Mysterious', 'description': 'Misterioso y enigm√°tico', 'valence_score': -0.1},
            {'name': 'Uplifting', 'description': 'Inspirador y elevador', 'valence_score': 0.7},
            {'name': 'Melancholic', 'description': 'Melanc√≥lico y reflexivo', 'valence_score': -0.3},
            {'name': 'Powerful', 'description': 'Poderoso y dominante', 'valence_score': 0.6},
        ]
        
        for mood_data in moods_data:
            mood, created = Mood.objects.get_or_create(
                name=mood_data['name'],
                defaults=mood_data
            )
            if created:
                self.stdout.write(f'  ‚úÖ Mood creado: {mood.name}')

        self.stdout.write(
            self.style.SUCCESS('‚úÖ Datos de ejemplo creados!')
        )

    def fingerprint_existing_tracks(self):
        """Generar fingerprints para tracks existentes"""
        self.stdout.write('üéØ Generando fingerprints para tracks existentes...')
        
        # Obtener tracks sin fingerprint
        tracks_without_fingerprint = Track.objects.filter(
            fingerprint_status__in=['pending', 'error']
        )
        
        if not tracks_without_fingerprint.exists():
            self.stdout.write('‚ÑπÔ∏è  No hay tracks pendientes de fingerprinting')
            return

        self.stdout.write(
            f'üìä Encontrados {tracks_without_fingerprint.count()} tracks para procesar'
        )

        processed = 0
        errors = 0

        # Procesar cada track
        for track in tracks_without_fingerprint:
            self.stdout.write(f'üéµ Procesando: {track.title} - {track.artist.name}')
            
            # Verificar que el archivo existe
            if not track.file or not os.path.exists(track.file.path):
                self.stdout.write(
                    self.style.WARNING(f'‚ö†Ô∏è  Archivo no encontrado para track {track.id}')
                )
                track.fingerprint_status = 'error'
                track.fingerprint_error = 'Archivo no encontrado'
                track.save()
                errors += 1
                continue

            # Asignar g√©nero y mood si no los tiene
            if not track.genre:
                track.genre = predict_genre_from_filename(track.file.name)
                self.stdout.write(f'  üìÇ G√©nero asignado: {track.genre.name}')

            if not track.mood:
                track.mood = predict_mood_from_filename(track.file.name)
                self.stdout.write(f'  üòä Mood asignado: {track.mood.name}')

            # Marcar como track de referencia si no est√° marcado
            if not track.is_reference_track:
                track.is_reference_track = True
                track.reference_source = 'admin_migration'

            track.save()

            # Ejecutar fingerprinting directamente (sin Celery en desarrollo)
            try:
                self.stdout.write(f'  üöÄ Generando fingerprint para track {track.id}...')
                result = fingerprint_track(track.id)  # Llamada directa
                
                if result.get('success'):
                    self.stdout.write(
                        self.style.SUCCESS(f'  ‚úÖ Fingerprint completado: {result.get("fingerprints_count", 0)} features')
                    )
                    processed += 1
                else:
                    self.stdout.write(
                        self.style.ERROR(f'  ‚ùå Error en fingerprint: {result.get("error")}')
                    )
                    errors += 1
                    
            except Exception as e:
                self.stdout.write(
                    self.style.ERROR(f'  ‚ùå Error procesando track: {str(e)}')
                )
                errors += 1

        self.stdout.write(
            self.style.SUCCESS(
                f'‚úÖ Fingerprinting completado: {processed} exitosos, {errors} errores'
            )
        )

    def show_statistics(self):
        """Mostrar estad√≠sticas del sistema"""
        self.stdout.write('üìä Estad√≠sticas del sistema:')
        
        total_tracks = Track.objects.count()
        fingerprinted_tracks = Track.objects.filter(fingerprint_status='completed').count()
        pending_tracks = Track.objects.filter(fingerprint_status='pending').count()
        error_tracks = Track.objects.filter(fingerprint_status='error').count()
        reference_tracks = Track.objects.filter(is_reference_track=True).count()
        
        self.stdout.write(f'  üìÄ Total tracks: {total_tracks}')
        self.stdout.write(f'  ‚úÖ Fingerprinted: {fingerprinted_tracks}')
        self.stdout.write(f'  ‚è≥ Pendientes: {pending_tracks}')
        self.stdout.write(f'  ‚ùå Con errores: {error_tracks}')
        self.stdout.write(f'  üéØ Tracks de referencia: {reference_tracks}')
        
        # Estad√≠sticas de reconocimiento
        from api.models import Recognition
        total_recognitions = Recognition.objects.count()
        successful_recognitions = Recognition.objects.filter(recognition_status='found').count()
        failed_recognitions = Recognition.objects.filter(recognition_status='not_found').count()
        
        self.stdout.write(f'  üîç Total reconocimientos: {total_recognitions}')
        self.stdout.write(f'  ‚úÖ Exitosos: {successful_recognitions}')
        self.stdout.write(f'  ‚ùå Fallidos: {failed_recognitions}')
        
        if total_recognitions > 0:
            success_rate = (successful_recognitions / total_recognitions) * 100
            self.stdout.write(f'  üìà Tasa de √©xito: {success_rate:.1f}%')

        # Estad√≠sticas de g√©neros y moods
        genres_count = Genre.objects.count()
        moods_count = Mood.objects.count()
        artists_count = Artist.objects.count()
        
        self.stdout.write(f'  üé≠ G√©neros: {genres_count}')
        self.stdout.write(f'  üòä Moods: {moods_count}')
        self.stdout.write(f'  üë®‚Äçüé§ Artistas: {artists_count}')
        
        # Mostrar distribuci√≥n de g√©neros
        self.stdout.write('\nüìä Distribuci√≥n por g√©neros:')
        genre_stats = Genre.objects.annotate(
            track_count=models.Count('tracks')
        ).order_by('-track_count')[:5]
        
        for genre in genre_stats:
            self.stdout.write(f'  - {genre.name}: {genre.track_count} tracks')
        
        # Mostrar artistas con m√°s tracks
        self.stdout.write('\nüé§ Top artistas:')
        artist_stats = Artist.objects.annotate(
            track_count=models.Count('tracks')
        ).order_by('-track_count')[:5]
        
        for artist in artist_stats:
            self.stdout.write(f'  - {artist.name}: {artist.track_count} tracks') 